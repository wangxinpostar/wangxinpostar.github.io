<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java面向对象面试题</title>
    <url>/2023/09/03/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h2 id="Java语言有哪些特点？"><a href="#Java语言有哪些特点？" class="headerlink" title="Java语言有哪些特点？"></a>Java语言有哪些特点？</h2><ul>
<li>面向对象（封装，继承，多态）；</li>
<li>平台无关性，平台无关性的具体表现在于，Java 是“一次编写，到处运行（Write Once，Run any Where）”的语言，因此采用 Java 语言编写的程序具有很好的可移植性，而保证这一点的正是 Java 的虚拟机机制。在引入虚拟机之后，Java 语言在不同的平台上运行不需要重新编译。</li>
<li>可靠性、安全性；</li>
<li>支持多线程</li>
<li>支持网络编程并且很方便。Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便；</li>
<li>编译与解释并存</li>
</ul>
<h2 id="java面向对象的理解？面向对象的特征？"><a href="#java面向对象的理解？面向对象的特征？" class="headerlink" title="java面向对象的理解？面向对象的特征？"></a>java面向对象的理解？面向对象的特征？</h2><h3 id="面向对象的理解："><a href="#面向对象的理解：" class="headerlink" title="面向对象的理解："></a>面向对象的理解：</h3><p>在java中万事万物皆对象。类是对相同事物的一种抽象、是不可见的，对象具体的、可见的。由对象到类的过程是抽象的过程，由类到对象的过程是实例化的过程。</p>
<h3 id="面向对象的特征："><a href="#面向对象的特征：" class="headerlink" title="面向对象的特征："></a>面向对象的特征：</h3><p><strong>封装</strong>：隐藏了类的内部实现机制，对外界而言它的内部细节是隐藏的，暴露给外界的只是它的访问方法。例如在属性的修饰符上我们往往用的private私有的，这样其它类要想访问就通过get和set方法。因此封装可以程序员按照既定的方式调用方法，不必关心方法的内部实现，便于使用； 便于修改，增强 代码的可维护性。<br><strong>继承</strong>：即常说的is-a关系。子类继承父类，表明子类是一种特殊的父类，并且具有父类所不具有的一些属性或方法。通过extends关键字来实现继承。Java中的继承是单继承，即一个子类只允许有一个父类。<br><strong>多态</strong>：是指的是首先两个类有继承关系，其次子类重写了父类的方法，最后父类引用指向子类对象。</p>
<h2 id="Java中实现多态的机制是什么？"><a href="#Java中实现多态的机制是什么？" class="headerlink" title="Java中实现多态的机制是什么？"></a>Java中实现多态的机制是什么？</h2><p>Java中的多态靠的是父类或接口定义的引用变量可以指向子类或具体实现类的实例对象，而程 序调用的方法在运行期才动态绑定</p>
<h2 id="构造方法有哪些特性？"><a href="#构造方法有哪些特性？" class="headerlink" title="构造方法有哪些特性？"></a>构造方法有哪些特性？</h2><ol>
<li>名字与类名相同；</li>
<li>没有返回值，但不能用void声明构造函数；</li>
<li>生成类的对象时自动执行，无需调用。</li>
</ol>
<h2 id="构造器（constructor）是否可被重写（override）？"><a href="#构造器（constructor）是否可被重写（override）？" class="headerlink" title="构造器（constructor）是否可被重写（override）？"></a>构造器（constructor）是否可被重写（override）？</h2><p>构造器不能被继承，因此不能被重写，但可以被重载。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Java语法面试题</title>
    <url>/2023/09/03/Java%E8%AF%AD%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h2 id="一个“-java”源文件中是否可以包含多个类（不是内部类）有什么限制"><a href="#一个“-java”源文件中是否可以包含多个类（不是内部类）有什么限制" class="headerlink" title="一个“.java”源文件中是否可以包含多个类（不是内部类）有什么限制?"></a>一个“.java”源文件中是否可以包含多个类（不是内部类）有什么限制?</h2><p>可以；必须只有一个<strong>public类名与文件名相同</strong>。</p>
<h2 id="char-型变量中能不能存储一个中文汉字，为什么？"><a href="#char-型变量中能不能存储一个中文汉字，为什么？" class="headerlink" title="char 型变量中能不能存储一个中文汉字，为什么？"></a>char 型变量中能不能存储一个中文汉字，为什么？</h2><p>char 类型可以存储一个中文汉字，因为Java中使用的编码是Unicode编码，一个char 类型占2个字节（16 比特），所以放一个中文是没问题的。</p>
<h2 id="switch-是否能作用在-byte-上，能否作用在-long-上，能否作用在-String-上"><a href="#switch-是否能作用在-byte-上，能否作用在-long-上，能否作用在-String-上" class="headerlink" title="switch 是否能作用在 byte 上，能否作用在 long 上，能否作用在 String 上?"></a>switch 是否能作用在 byte 上，能否作用在 long 上，能否作用在 String 上?</h2><p>switch（expr）中，expr 可以是 byte、short、char、int、枚举类型（enum）、字符串（String）</p>
<h2 id="Math-round-11-5-等于多少？Math-round-11-5-又等于多少"><a href="#Math-round-11-5-等于多少？Math-round-11-5-又等于多少" class="headerlink" title="Math.round(11.5)等于多少？Math.round(- 11.5) 又等于多少?"></a>Math.round(11.5)等于多少？Math.round(- 11.5) 又等于多少?</h2><p>Math.round(11.5)的返回值是12，Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数上加0.5然后进行取整。</p>
<h2 id="如何将数值型字符转换为数字？"><a href="#如何将数值型字符转换为数字？" class="headerlink" title="如何将数值型字符转换为数字？"></a>如何将数值型字符转换为数字？</h2><p>调用数值类型相应包装类中的方法 parse***(String)或 valueOf(String) 即可返回相应基本类型或包装类型数值；</p>
<h2 id="如何取小数点前两位并四舍五入"><a href="#如何取小数点前两位并四舍五入" class="headerlink" title="如何取小数点前两位并四舍五入?"></a>如何取小数点前两位并四舍五入?</h2><p>可用该数字构造一 java.math.BigDecimal 对象,再利用其 round()方法 进行四舍五入到保留小数点后两位,再将其转换为字符串截取最后两位。</p>
<h2 id="如何理解Java中的泛型是伪泛型？"><a href="#如何理解Java中的泛型是伪泛型？" class="headerlink" title="如何理解Java中的泛型是伪泛型？"></a>如何理解Java中的泛型是伪泛型？</h2><p>泛型中类型擦除 Java泛型这个特性是从JDK 1.5才开始加入的，因此为了兼容之前的版本，Java泛型的实现采取了“伪泛型”的策略，即Java在语法上支持泛型，但是在编译阶段会进行所谓的“类型擦除”（Type Erasure），将所有的泛型表示（尖括号中的内容）都替换为具体的类型（其对应的原生态类型），就像完全没有泛型一样。</p>
<h2 id="注解的作用？"><a href="#注解的作用？" class="headerlink" title="注解的作用？"></a>注解的作用？</h2><ol>
<li><strong>生成文档</strong>：通过代码里标识的元数据生成javadoc文档</li>
<li><strong>编译检查</strong>：过代码里标识的元数据让编译器在编译期间进行检查验证</li>
<li><strong>编译时动态处理</strong>：编译时通过代码里标识的元数据动态处理，例如动态生成代码</li>
<li><strong>运行时动态处理</strong>：运行时通过代码里标识的元数据动态处理，例如使用反射注入实例</li>
</ol>
<h2 id="注解的常见分类？"><a href="#注解的常见分类？" class="headerlink" title="注解的常见分类？"></a>注解的常见分类？</h2><p><strong>Java自带的标准注解</strong></p>
<ol>
<li><strong>@Override：</strong>标明重写某个方法</li>
<li><strong>@Deprecated：</strong>标明某个类或方法过时****</li>
<li><strong>@SuppressWarnings：</strong>标明要忽略的警告****</li>
</ol>
<p><strong>元注解</strong>:元注解是用于定义注解的注解</p>
<p>**@Retention、@Target、@Inherited、@Documented **</p>
<ol>
<li><strong>@Retention</strong>用于标明注解被保留的阶段 </li>
<li><strong>@Target</strong>用于标明注解使用的范围 </li>
<li><strong>@Inherited</strong>用于标明注解可继承 </li>
<li><strong>@Documented</strong>用于标明是否生成javadoc文档 自定义注解，可以根据自己的需求定义注解，并可用元注解对自定义注解进行注解。</li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL面试题</title>
    <url>/2023/09/02/Mysql/</url>
    <content><![CDATA[<h2 id="Myql中的事务-？"><a href="#Myql中的事务-？" class="headerlink" title="Myql中的事务 ？"></a>Myql中的事务 ？</h2><p>事务是由一组SQL语句组成的逻辑处理单元，是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。事务具有以下4个属性，通常简称为事务的ACID属性:</p>
<ul>
<li><strong>原子性</strong>（Atomicity）：<strong>事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行</strong>。比如在同一个事务中的SQL语句，要么全部执行成功，要么全部执行失败。回滚可以用日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</li>
<li><strong>一致性</strong>（Consistent）：<strong>在事务开始和完成时，数据都必须保持一致状态</strong>。这意味着所有相关的数据规则都必须应用于事务的修改，以保持数据的完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。 以转账为例子，A向B转账，假设转账之前这两个用户的钱加起来总共是2000，那么A向B转账之后，不管这两个账户怎么转，A用户的钱和B用户的钱加起来的总额还是2000，这个就是事务的一致性。</li>
<li><strong>隔离性</strong>（Isolation）：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。 <strong>隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离</strong>。即要达到这么一种效果：对于任意两个并发的事务 T1 和 T2，在事务 T1 看来，T2 要么在 T1 开始之前就已经结束，要么在 T1 结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。</li>
<li><strong>持久性</strong>（Durable）：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。 　可以通过数据库备份和恢复来实现，在系统发生奔溃时，使用备份的数据库进行数据恢复。</li>
</ul>
<h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><ul>
<li><strong>读未提交:</strong> <strong>一个事务还没提交时，它做的变更就能被别的事务看到</strong>。</li>
<li><strong>读提交</strong>: 一个事务提交之后，它做的变更才会被其他事务看到。</li>
<li><strong>可重复读</strong> : <strong>一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的</strong>。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</li>
<li><strong>串行化</strong>: 顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li>
</ul>
<p><img src="/../Gallery/img/v2-3220735eb5af67e63b5a94bd1481e4ba_720w.webp" alt="Alt text"></p>
<h3 id="MySQL-默认采用自动提交模式，事务隔离级别默认是可重复读REPEATABLE-READ-。如果不显式使用-START-TRANSACTION-语句来开始一个事务，那么每个查询都会被当做一个事务自动提交。"><a href="#MySQL-默认采用自动提交模式，事务隔离级别默认是可重复读REPEATABLE-READ-。如果不显式使用-START-TRANSACTION-语句来开始一个事务，那么每个查询都会被当做一个事务自动提交。" class="headerlink" title="MySQL 默认采用自动提交模式，事务隔离级别默认是可重复读REPEATABLE-READ 。如果不显式使用 START TRANSACTION 语句来开始一个事务，那么每个查询都会被当做一个事务自动提交。"></a>MySQL 默认采用<strong>自动提交模式</strong>，事务隔离级别默认是可重复读<code>REPEATABLE-READ</code> 。如果不显式使用 START TRANSACTION 语句来开始一个事务，那么每个查询都会被当做一个事务自动提交。</h3><h2 id="MySQL支持的存储引擎"><a href="#MySQL支持的存储引擎" class="headerlink" title="MySQL支持的存储引擎?"></a>MySQL支持的存储引擎?</h2><p>show engines;<img src="/../Gallery/img/1661133012@b6cce781ce2e88e668e9591c0f1163e4.png" alt="Alt text"></p>
<h2 id="MyISAM和InnoDB的区别？"><a href="#MyISAM和InnoDB的区别？" class="headerlink" title="MyISAM和InnoDB的区别？"></a>MyISAM和InnoDB的区别？</h2><h3 id="MyISAM（3-个文件）特点：只读之类的数据分析的项目"><a href="#MyISAM（3-个文件）特点：只读之类的数据分析的项目" class="headerlink" title="MyISAM（3 个文件）特点：只读之类的数据分析的项目"></a>MyISAM（3 个文件）特点：只读之类的数据分析的项目</h3><ol>
<li>支持表级别的锁（插入和更新会锁表）。不支持事务</li>
<li>拥有较高的插入（insert）和查询（select）速度</li>
<li>MyISAM 用一个变量保存了整个表的行数</li>
</ol>
<h3 id="InnoDB（2-个文件）特点：经常更新的表，存在并发读写或者有事务处理的业务系统。"><a href="#InnoDB（2-个文件）特点：经常更新的表，存在并发读写或者有事务处理的业务系统。" class="headerlink" title="InnoDB（2 个文件）特点：经常更新的表，存在并发读写或者有事务处理的业务系统。"></a>InnoDB（2 个文件）特点：经常更新的表，存在并发读写或者有事务处理的业务系统。</h3><ol>
<li>支持事务，支持外键，因此数据的完整性、一致性更高</li>
<li>支持行级别的锁和表级别的锁</li>
<li>支持读写并发，写不阻塞读（MVCC）</li>
<li>特殊的索引存放方式，可以减少IO，提升查询效率</li>
</ol>
<h2 id="如何选择存储引擎？"><a href="#如何选择存储引擎？" class="headerlink" title="如何选择存储引擎？"></a>如何选择存储引擎？</h2><h3 id="InnoDB：适用对数据一致性要求比较高，需要事务支持"><a href="#InnoDB：适用对数据一致性要求比较高，需要事务支持" class="headerlink" title="InnoDB：适用对数据一致性要求比较高，需要事务支持"></a>InnoDB：适用对数据一致性要求比较高，需要事务支持</h3><h3 id="MyISAM：适用数据查询多更新少，对查询性能要求比较高。"><a href="#MyISAM：适用数据查询多更新少，对查询性能要求比较高。" class="headerlink" title="MyISAM：适用数据查询多更新少，对查询性能要求比较高。"></a>MyISAM：适用数据查询多更新少，对查询性能要求比较高。</h3><h2 id="索引类型有哪些？"><a href="#索引类型有哪些？" class="headerlink" title="索引类型有哪些？"></a>索引类型有哪些？</h2><h3 id="1）单列索引：一个索引只包含单个列，但一个表中可以有多个单列索引。"><a href="#1）单列索引：一个索引只包含单个列，但一个表中可以有多个单列索引。" class="headerlink" title="1）单列索引：一个索引只包含单个列，但一个表中可以有多个单列索引。"></a>1）单列索引：一个索引只包含单个列，但一个表中可以有多个单列索引。</h3><p>主键索引：主键是一种唯一性索引，但它必须指定为PRIMARY KEY，每个表只能有一个主键。</p>
<h3 id="2）复合索引：符合索引遵循索引最左匹配原则"><a href="#2）复合索引：符合索引遵循索引最左匹配原则" class="headerlink" title="2）复合索引：符合索引遵循索引最左匹配原则"></a>2）复合索引：符合索引遵循索引最左匹配原则</h3><h3 id="3）全文索引，只有在MyISAM引擎上才能使用，意思。一般开发中，不贵用到全文索引，因为其占用很大的物理空间和降低了记录修改性，故较为少用。"><a href="#3）全文索引，只有在MyISAM引擎上才能使用，意思。一般开发中，不贵用到全文索引，因为其占用很大的物理空间和降低了记录修改性，故较为少用。" class="headerlink" title="3）全文索引，只有在MyISAM引擎上才能使用，意思。一般开发中，不贵用到全文索引，因为其占用很大的物理空间和降低了记录修改性，故较为少用。"></a>3）全文索引，只有在MyISAM引擎上才能使用，意思。一般开发中，不贵用到全文索引，因为其占用很大的物理空间和降低了记录修改性，故较为少用。</h3><h2 id="索引的应用场景？"><a href="#索引的应用场景？" class="headerlink" title="索引的应用场景？"></a>索引的应用场景？</h2><h3 id="需要建索引的情况"><a href="#需要建索引的情况" class="headerlink" title="需要建索引的情况"></a>需要建索引的情况</h3><ol>
<li>主键自动创建唯一索引</li>
<li>较频繁的作为查询条件的字段</li>
<li>查询中排序的字段，查询中统计或者分组的字段</li>
</ol>
<h3 id="不需要建索引的情况"><a href="#不需要建索引的情况" class="headerlink" title="不需要建索引的情况"></a>不需要建索引的情况</h3><ol>
<li>表记录太少的字段</li>
<li>经常增删改的字段</li>
<li>唯一性太差的字段，不适合单独创建索引。比如性别，民族，政治面貌</li>
</ol>
<h2 id="索引的数据结构？"><a href="#索引的数据结构？" class="headerlink" title="索引的数据结构？"></a>索引的数据结构？</h2><h3 id="索引的数据结构是B-树（加强版多路平衡查找树）"><a href="#索引的数据结构是B-树（加强版多路平衡查找树）" class="headerlink" title="索引的数据结构是B+树（加强版多路平衡查找树）"></a>索引的数据结构是B+树（加强版多路平衡查找树）<img src="/../Gallery/img/1661135892@a76e3b01eecba05f65b44ac1a753b550.png" alt="Alt text"></h3><p>查找过程：如图所示，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。<br>优点：保证等值和范围查询的快速查找。</p>
<h2 id="MySQL中聚合函数有哪些？"><a href="#MySQL中聚合函数有哪些？" class="headerlink" title="MySQL中聚合函数有哪些？"></a>MySQL中聚合函数有哪些？</h2><h3 id="如sum-avg-count-max-min等"><a href="#如sum-avg-count-max-min等" class="headerlink" title="如sum. avg, count, max, min等"></a>如sum. avg, count, max, min等</h3><h2 id="SQL语句中关键字的执行顺序？"><a href="#SQL语句中关键字的执行顺序？" class="headerlink" title="SQL语句中关键字的执行顺序？"></a>SQL语句中关键字的执行顺序？</h2><h3 id="SQL的执行顺序：from—where–group-by—having—select—order-by"><a href="#SQL的执行顺序：from—where–group-by—having—select—order-by" class="headerlink" title="SQL的执行顺序：from—where–group by—having—select—order by"></a>SQL的执行顺序：from—where–group by—having—select—order by</h3><h2 id="什么是MVCC？"><a href="#什么是MVCC？" class="headerlink" title="什么是MVCC？"></a>什么是MVCC？</h2><p>MVCC,全称Multi-Version Concurrency Control,即多版本并发控制，是一种高并发版本控制器，一般用于数据库中对数据的并发访问。Mysql中的innoDB中就是使用这种方法来提高读写事务的并发性能。因为MVCC是一种不采用锁来控制事务的方式，是一种非堵塞、同时还可以解决脏读，不可重复读，幻读等事务隔离问题，但不能解决更新丢失问题。</p>
<h3 id="总之：就是MVCC是通过保存数据的历史版本，根据比较版本号来处理数据是否显示，从而达到读取数据的时候不需要加锁就可以保证事务隔离性的效果。"><a href="#总之：就是MVCC是通过保存数据的历史版本，根据比较版本号来处理数据是否显示，从而达到读取数据的时候不需要加锁就可以保证事务隔离性的效果。" class="headerlink" title="总之：就是MVCC是通过保存数据的历史版本，根据比较版本号来处理数据是否显示，从而达到读取数据的时候不需要加锁就可以保证事务隔离性的效果。"></a>总之：就是MVCC是通过保存数据的历史版本，根据比较版本号来处理数据是否显示，从而达到读取数据的时候不需要加锁就可以保证事务隔离性的效果。</h3><h2 id="什么是数据库死锁？"><a href="#什么是数据库死锁？" class="headerlink" title="什么是数据库死锁？"></a>什么是数据库死锁？</h2><h3 id="是指二个或者二个以上的进程在执行时候，因为争夺资源造成相互等待的现象，进程一直处于等待中，无法得到释放，这种状态就叫做死锁。"><a href="#是指二个或者二个以上的进程在执行时候，因为争夺资源造成相互等待的现象，进程一直处于等待中，无法得到释放，这种状态就叫做死锁。" class="headerlink" title="是指二个或者二个以上的进程在执行时候，因为争夺资源造成相互等待的现象，进程一直处于等待中，无法得到释放，这种状态就叫做死锁。"></a>是指二个或者二个以上的进程在执行时候，因为争夺资源造成相互等待的现象，进程一直处于等待中，无法得到释放，这种状态就叫做死锁。</h3><h2 id="MySQL锁分类"><a href="#MySQL锁分类" class="headerlink" title="MySQL锁分类?"></a>MySQL锁分类?</h2><h4 id="1-从对数据操作的类型分类"><a href="#1-从对数据操作的类型分类" class="headerlink" title="1.从对数据操作的类型分类"></a>1.从对数据操作的类型分类</h4><h3 id="读锁（共享锁）："><a href="#读锁（共享锁）：" class="headerlink" title="读锁（共享锁）："></a>读锁（共享锁）：</h3><p>针对同一份数据，多个读操作可以同时进行，不会互相影响 </p>
<h3 id="写锁（排他锁）："><a href="#写锁（排他锁）：" class="headerlink" title="写锁（排他锁）："></a>写锁（排他锁）：</h3><p>当前写操作没有完成前，它会阻断其他写锁和读锁 </p>
<h4 id="2-从对数据操作的范围分类"><a href="#2-从对数据操作的范围分类" class="headerlink" title="2.从对数据操作的范围分类"></a>2.从对数据操作的范围分类</h4><p>为了尽可能提高数据库的并发度，理论上每次只锁定当前操作的数据，即每次锁定的数据范围越小就会得到最大的并发度，但是管理锁是很耗资源的事情（涉及获取，检查，释放锁等动作），因此数据库系统需要在高并发响应和系统性能两方面进行平衡，这样就产生了“锁粒度（Lock granularity）”的概念。 </p>
<h3 id="表级锁："><a href="#表级锁：" class="headerlink" title="表级锁："></a>表级锁：</h3><p>开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低（MyISAM 和 MEMORY 存储引擎采用的是表级锁）；适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；</p>
<h3 id="行级锁："><a href="#行级锁：" class="headerlink" title="行级锁："></a>行级锁：</h3><p>开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高（InnoDB 存储引擎既支持行级锁也支持表级锁，但默认情况下是采用行级锁）； 适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。</p>
<h3 id="页面锁："><a href="#页面锁：" class="headerlink" title="页面锁："></a>页面锁：</h3><p>开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。 </p>
<h2 id="悲观锁和乐观锁的区别？"><a href="#悲观锁和乐观锁的区别？" class="headerlink" title="悲观锁和乐观锁的区别？"></a>悲观锁和乐观锁的区别？</h2><h3 id="悲观锁："><a href="#悲观锁：" class="headerlink" title="悲观锁："></a>悲观锁：</h3><p>每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据都会block直到它拿到锁。因此，悲观锁需要耗时比较的多，跟乐观锁比较，悲观锁是有数据库自己实现的，用的时候我们直接调用数据的相关语句就可以。</p>
<h3 id="乐观锁："><a href="#乐观锁：" class="headerlink" title="乐观锁："></a>乐观锁：</h3><p>用数据版本记录机制实现，这是乐观锁最常用的方式，所谓的数据版本，为数据增加一个版本号的字段，一般是通过为数据表增加一个数据类型的version字段实现，当读取数据时，将把二十年字段的值一同读取出来，数据每次更新都需要对version值加一，在我们提交更新的时候，判断数据表对应记录的当前版本信息与第一次取出来的version值进行对比，如果数据库的表当前版本号鱼取出来的version值相等，则给与更新否则认为过期数据不给与更新。</p>
<h2 id="实践中如何优化MySQL？"><a href="#实践中如何优化MySQL？" class="headerlink" title="实践中如何优化MySQL？"></a>实践中如何优化MySQL？</h2><h3 id="SQL语句及索引的优化"><a href="#SQL语句及索引的优化" class="headerlink" title="SQL语句及索引的优化"></a>SQL语句及索引的优化</h3><h3 id="数据库表结构的优化"><a href="#数据库表结构的优化" class="headerlink" title="数据库表结构的优化"></a>数据库表结构的优化</h3><h3 id="系统配置的优化"><a href="#系统配置的优化" class="headerlink" title="系统配置的优化"></a>系统配置的优化</h3><h3 id="硬件的优化"><a href="#硬件的优化" class="headerlink" title="硬件的优化"></a>硬件的优化</h3><h2 id="货币字段用什么类型？"><a href="#货币字段用什么类型？" class="headerlink" title="货币字段用什么类型？"></a>货币字段用什么类型？</h2><h3 id="如果货币单位是分，可以是int类型；如果坚持用元，则要用decimal类型。"><a href="#如果货币单位是分，可以是int类型；如果坚持用元，则要用decimal类型。" class="headerlink" title="如果货币单位是分，可以是int类型；如果坚持用元，则要用decimal类型。"></a>如果货币单位是分，可以是int类型；如果坚持用元，则要用decimal类型。</h3><p>但是是不能用float和double类型的，因为这两个类型是以二进制存储的，会有一定的误差。比如float类型如果你insert一个1234567.23，查询出来的结果可能是1234567.25。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>餐道</title>
    <url>/2023/09/13/reggie/</url>
    <content><![CDATA[<h1 id="餐道项目中的问题："><a href="#餐道项目中的问题：" class="headerlink" title="餐道项目中的问题："></a>餐道项目中的问题：</h1><h2 id="HTTP动词"><a href="#HTTP动词" class="headerlink" title="HTTP动词"></a>HTTP动词</h2><h3 id="对于如何操作资源，有相应的HTTP动词对应，常见的动词有如下五个（括号里表示SQL对应的命令）："><a href="#对于如何操作资源，有相应的HTTP动词对应，常见的动词有如下五个（括号里表示SQL对应的命令）：" class="headerlink" title="对于如何操作资源，有相应的HTTP动词对应，常见的动词有如下五个（括号里表示SQL对应的命令）："></a>对于如何操作资源，有相应的HTTP动词对应，常见的动词有如下五个（括号里表示SQL对应的命令）：</h3><ul>
<li>GET（SELECT）：从服务器取出资源（一项或多项）</li>
<li>POST（CREATE）：在服务器新建一个资源</li>
<li>PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）</li>
<li>PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）</li>
<li>DELETE（DELETE）：从服务器删除资源</li>
</ul>
<h2 id="前端传过来uid精度丢失问题："><a href="#前端传过来uid精度丢失问题：" class="headerlink" title="前端传过来uid精度丢失问题："></a>前端传过来uid精度丢失问题：</h2><p><strong>页面中js处理long型数字只能精确到前16位</strong></p>
<p>![屏幕截图 2023-09-02 143920](.&#x2F;assets&#x2F;屏幕截图 2023-09-02 143920.png)</p>
<h2 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h2><h3 id="前端用String类型的雪花ID保持精度，后端及数据库继续使用Long-BigINT-类型不影响数据库查询执行效率。"><a href="#前端用String类型的雪花ID保持精度，后端及数据库继续使用Long-BigINT-类型不影响数据库查询执行效率。" class="headerlink" title="前端用String类型的雪花ID保持精度，后端及数据库继续使用Long(BigINT)类型不影响数据库查询执行效率。"></a><strong>前端用String类型的雪花ID保持精度，后端及数据库继续使用Long(BigINT)类型不影响数据库查询执行效率。</strong></h3><h4 id="具体实现步骤"><a href="#具体实现步骤" class="headerlink" title="具体实现步骤:"></a>具体实现步骤:</h4><ol>
<li>提供对象转换器JacksonobjectMapper，基于Jackson进行Java对象到json数据的转换（资料中已经提供，直接复制到’项目中使用)</li>
<li>在WebMvcConfig配置类中扩展Spring mvc的消息转换器，在此消息转换器中使用提供的对象转换器进行Java对象到json数据的转换</li>
</ol>
<p><strong>可以在entity中的id上方加注解  @JsonSerialize(using &#x3D; ToStringSerializer.class)</strong></p>
<h2 id="页面复用：增加员工和修改员工使用公共页面add-html"><a href="#页面复用：增加员工和修改员工使用公共页面add-html" class="headerlink" title="页面复用：增加员工和修改员工使用公共页面add.html"></a>页面复用：增加员工和修改员工使用公共页面add.html</h2><h2 id="MybatisPlus公共字段自动填充"><a href="#MybatisPlus公共字段自动填充" class="headerlink" title="MybatisPlus公共字段自动填充"></a>MybatisPlus公共字段自动填充</h2><p>![屏幕截图 2023-09-02 154750](C:\Users\wangx\Desktop\学习\面试\屏幕截图 2023-09-02 154750.png)</p>
<p><strong>Mybatis Plus公共字段自动填充，也就是在插入或者更新的时候为指定字段赋予指定的值，使用它的好处就是可以统一对这些字段进行处理，避免了重复代码。</strong></p>
<h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤:"></a>实现步骤:</h3><ol>
<li><p>在实体类的属性上加入@TableField注解，指定自动填充的策略;</p>
</li>
<li><p>按照框架要求编写元数据对象处理器，在此类中统一为公共字段赋值，此类需要实现MetaObjectHandler接口</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> HttpServletRequest request;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入时填充</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> metaObject</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">    metaObject.setValue(<span class="string">&quot;createTime&quot;</span>, LocalDateTime.now());</span><br><span class="line">    metaObject.setValue(<span class="string">&quot;updateTime&quot;</span>, LocalDateTime.now());</span><br><span class="line">    metaObject.setValue(<span class="string">&quot;createUser&quot;</span>, request.getSession().getAttribute(<span class="string">&quot;employee&quot;</span>));</span><br><span class="line">    metaObject.setValue(<span class="string">&quot;updateUser&quot;</span>, request.getSession().getAttribute(<span class="string">&quot;employee&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更新时填充</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> metaObject</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">    metaObject.setValue(<span class="string">&quot;updateTime&quot;</span>, LocalDateTime.now());</span><br><span class="line">    metaObject.setValue(<span class="string">&quot;updateUser&quot;</span>, request.getSession().getAttribute(<span class="string">&quot;employee&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="餐道项目优化："><a href="#餐道项目优化：" class="headerlink" title="餐道项目优化："></a>餐道项目优化：</h1><h2 id="缓存优化："><a href="#缓存优化：" class="headerlink" title="缓存优化："></a>缓存优化：</h2><ul>
<li><h3 id="缓存短信验证码"><a href="#缓存短信验证码" class="headerlink" title="缓存短信验证码"></a>缓存短信验证码</h3></li>
<li><h3 id="缓存菜品数据"><a href="#缓存菜品数据" class="headerlink" title="缓存菜品数据"></a>缓存菜品数据</h3></li>
<li><h3 id="Spring-Cache"><a href="#Spring-Cache" class="headerlink" title="Spring Cache"></a>Spring Cache</h3></li>
<li><h3 id="缓存套餐数据"><a href="#缓存套餐数据" class="headerlink" title="缓存套餐数据"></a>缓存套餐数据</h3></li>
</ul>
<h2 id="Spring-Cache-1"><a href="#Spring-Cache-1" class="headerlink" title="Spring Cache:"></a>Spring Cache:</h2><h3 id="Cacheable-只能序列化成String类型"><a href="#Cacheable-只能序列化成String类型" class="headerlink" title="@Cacheable 只能序列化成String类型"></a>@Cacheable 只能序列化成String类型</h3><h2 id="mysql主从配置（全是坑）"><a href="#mysql主从配置（全是坑）" class="headerlink" title="mysql主从配置（全是坑）"></a>mysql主从配置（全是坑）</h2><h3 id="先绑定数据库，再创建绑定的数据库"><a href="#先绑定数据库，再创建绑定的数据库" class="headerlink" title="先绑定数据库，再创建绑定的数据库"></a>先绑定数据库，再创建绑定的数据库</h3><p><a href="https://cloud.tencent.com/developer/article/1857232">MySQL8 主从复制踩坑指南-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">8.0</span>版本</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> `linux`@`<span class="operator">%</span>` IDENTIFIED <span class="keyword">WITH</span> caching_sha2_password <span class="keyword">BY</span> <span class="string">&#x27;020424&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">GRANT</span> Replication Slave <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> `linux`@`<span class="operator">%</span>`;</span><br><span class="line"></span><br><span class="line">#配置到从库到主库</span><br><span class="line">change master <span class="keyword">to</span> master_host<span class="operator">=</span><span class="string">&#x27;192.168.3.4&#x27;</span>,master_user<span class="operator">=</span><span class="string">&#x27;linux&#x27;</span>,master_password<span class="operator">=</span><span class="string">&#x27;020424&#x27;</span>,master_log_file<span class="operator">=</span><span class="string">&#x27;NBPLUS-bin.000152&#x27;</span>,master_log_pos<span class="operator">=</span> <span class="number">60756</span>,get_master_public_key<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#报错Slave_SQL_Running: <span class="keyword">No</span></span><br><span class="line"></span><br><span class="line">stop slave;                                                      </span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> SQL_SLAVE_SKIP_COUNTER<span class="operator">=</span><span class="number">1</span>; <span class="keyword">START</span> SLAVE;            </span><br><span class="line"><span class="keyword">start</span> slave;     </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#报错discard long <span class="type">time</span> <span class="keyword">none</span> received connection. , jdbcUrl : jdbc:mysql:<span class="operator">/</span><span class="operator">/</span><span class="number">192.168</span><span class="number">.193</span><span class="number">.131</span>:<span class="number">3306</span><span class="operator">/</span>reggie?serverTimezone<span class="operator">=</span>Asia<span class="operator">/</span>Shanghai<span class="operator">&amp;</span>useUnicode<span class="operator">=</span><span class="literal">true</span><span class="operator">&amp;</span>characterEncoding<span class="operator">=</span>utf<span class="number">-8</span><span class="operator">&amp;</span>zeroDateTimeBehavior<span class="operator">=</span>convertToNull<span class="operator">&amp;</span>useSSL<span class="operator">=</span><span class="literal">false</span><span class="operator">&amp;</span>allowPublicKeyRetrieval<span class="operator">=</span><span class="literal">true</span>, jdbcUrl : jdbc:mysql:<span class="operator">/</span><span class="operator">/</span><span class="number">192.168</span><span class="number">.193</span><span class="number">.131</span>:<span class="number">3306</span><span class="operator">/</span>reggie?serverTimezone<span class="operator">=</span>Asia<span class="operator">/</span>Shanghai<span class="operator">&amp;</span>useUnicode<span class="operator">=</span><span class="literal">true</span><span class="operator">&amp;</span>characterEncoding<span class="operator">=</span>utf<span class="number">-8</span><span class="operator">&amp;</span>zeroDateTimeBehavior<span class="operator">=</span>convertToNull<span class="operator">&amp;</span>useSSL<span class="operator">=</span><span class="literal">false</span><span class="operator">&amp;</span>allowPublicKeyRetrieval<span class="operator">=</span><span class="literal">true</span>, lastPacketReceivedIdleMillis : <span class="number">187498</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    System.setProperty(&quot;druid.mysql.usePingMethod&quot;,&quot;false&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">shardingsphere:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">names:</span></span><br><span class="line">      <span class="string">master,slave</span></span><br><span class="line">    <span class="attr">master:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/reggie?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false&amp;allowPublicKeyRetrieval=true</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">&quot;root&quot;</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">&quot;020424&quot;</span></span><br><span class="line">    <span class="attr">slave:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://192.168.193.131:3306/reggie?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false&amp;allowPublicKeyRetrieval=true</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">&quot;root&quot;</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">&quot;020424&quot;</span></span><br><span class="line">    <span class="attr">masterslave:</span></span><br><span class="line">      <span class="attr">load-balance-algorithm-type:</span> <span class="string">round_robin</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">dataSource</span></span><br><span class="line">      <span class="attr">master-data-source-name:</span> <span class="string">master</span></span><br><span class="line">      <span class="attr">slave-data-source-names:</span> <span class="string">slave</span></span><br><span class="line">  <span class="attr">props:</span></span><br><span class="line">    <span class="attr">sql:</span></span><br><span class="line">      <span class="attr">show:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">main:</span></span><br><span class="line">  <span class="attr">allow-bean-definition-overriding:</span> <span class="literal">true</span></span><br><span class="line">  </span><br><span class="line">  <span class="string">//</span>    <span class="string">解决druid监控页面sql监控报错</span></span><br><span class="line">  <span class="attr">spring:</span></span><br><span class="line">  	<span class="attr">shardingsphere:</span></span><br><span class="line">  		<span class="attr">datasource:</span></span><br><span class="line">  			<span class="attr">testWhileIdle:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><p><img src="/../Gallery/img/klg5gq7i21.png" alt="![Alt text](assets/klg5gq7i21.png)"></p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment">#监听端口</span></span><br><span class="line">server &#123;</span><br><span class="line">            listen       80<span class="comment">;   #监听端口</span></span><br><span class="line">            server_name  www.mingongge.com<span class="comment">;  #域名信息</span></span><br><span class="line">            location / &#123;</span><br><span class="line">                root   /www/www<span class="comment">;   #网站根目录</span></span><br><span class="line">                index  index.html index.htm<span class="comment">;  #默认首页类型</span></span><br><span class="line">                deny 192.168.2.11<span class="comment">;   #禁止访问的ip地址，可以为all</span></span><br><span class="line">                allow 192.168.3.44； <span class="comment">#允许访问的ip地址，可以为all</span></span><br><span class="line">            &#125;</span><br><span class="line">&#125;           </span><br></pre></td></tr></table></figure>

<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment">#静态资源配置</span></span><br><span class="line">server &#123;  </span><br><span class="line">    listen 80<span class="comment">;  	</span></span><br><span class="line">    server_name mingongge.com<span class="comment">;  </span></span><br><span class="line">    location /static &#123;      </span><br><span class="line">      root /wwww/web/web_static_site<span class="comment">; </span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment">#反向代理</span></span><br><span class="line">http &#123;</span><br><span class="line">.............</span><br><span class="line">    upstream product_server&#123;</span><br><span class="line">        127.0.0.1:8081<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    upstream admin_server&#123;</span><br><span class="line">        127.0.0.1:8082<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    upstream test_server&#123;</span><br><span class="line">        127.0.0.1:8083<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">      </span><br><span class="line">  <span class="comment">#默认指向product的server</span></span><br><span class="line">  location / &#123;</span><br><span class="line">      proxy_pass http://product_server<span class="comment">;</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  location /product/&#123;</span><br><span class="line">      proxy_pass http://product_server<span class="comment">;</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">  location /admin/ &#123;</span><br><span class="line">      proxy_pass http://admin_server<span class="comment">;</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">  location /test/ &#123;</span><br><span class="line">      proxy_pass http://test_server<span class="comment">;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment">#负载均衡</span></span><br><span class="line">upstream server_pools &#123; </span><br><span class="line">  server 192.168.1.11:8880   <span class="attr">weight</span>=<span class="number">5</span><span class="comment">;</span></span><br><span class="line">  server 192.168.1.12:9990   <span class="attr">weight</span>=<span class="number">1</span><span class="comment">;</span></span><br><span class="line">  server 192.168.1.13:8989   <span class="attr">weight</span>=<span class="number">6</span><span class="comment">;</span></span><br><span class="line">  <span class="comment">#weigth参数表示权值，权值越高被分配到的几率越大</span></span><br><span class="line">&#125;</span><br><span class="line">server &#123;  </span><br><span class="line">  listen 80<span class="comment">; </span></span><br><span class="line">  server_name mingongge.com<span class="comment">;</span></span><br><span class="line">  location / &#123;    </span><br><span class="line">  proxy_pass http://server_pools<span class="comment">; </span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>尚可点评</title>
    <url>/2023/09/26/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84/</url>
    <content><![CDATA[<h1 id="高并发抢优惠卷"><a href="#高并发抢优惠卷" class="headerlink" title="高并发抢优惠卷"></a>高并发抢优惠卷</h1><h2 id="单体项目"><a href="#单体项目" class="headerlink" title="单体项目"></a>单体项目</h2><h3 id="乐观锁（超卖，基于CAS）"><a href="#乐观锁（超卖，基于CAS）" class="headerlink" title="乐观锁（超卖，基于CAS）"></a>乐观锁（超卖，基于<code>CAS</code>）</h3><p>在代码中静待获取库存<code>stock</code>并更新会导致并发时读取到脏数据，<code>Integer stock = voucher.getStock();</code>获取到库存量时在后面执行语句</p>
<p><code>boolean success = seckillVoucherService.updateById(voucher.setStock(stock - 1));</code></p>
<p>在此期间，数据库中的<code>stock</code>已被其他线程所改变，最后会导致优惠卷超额发放</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">stock</span> <span class="operator">=</span> voucher.getStock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (beginTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">    <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">endTime</span> <span class="operator">=</span> voucher.getEndTime();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (endTime.isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">    <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (stock &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.updateById(voucher.setStock(stock - <span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p>更改为以下代码可以避免并发时带来的错误</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update().setSql(<span class="string">&quot;stock = stock - 1&quot;</span>).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).update();</span><br></pre></td></tr></table></figure>

<p>发现出现了超卖问题，于是采用<code>CAS</code>自旋乐观锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.lambdaUpdate().setSql(<span class="string">&quot;stock = stock - 1&quot;</span>).eq(SeckillVoucher::getVoucherId,voucherId).eq(SeckillVoucher::getStock,stock).update();</span><br></pre></td></tr></table></figure>

<p>发现失败率太高，于是进行如下改进</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.lambdaUpdate().setSql(<span class="string">&quot;stock = stock - 1&quot;</span>).eq(SeckillVoucher::getVoucherId, voucherId).gt(SeckillVoucher::getStock, <span class="number">0</span>).update();</span><br></pre></td></tr></table></figure>

<h3 id="悲观锁（一人一单，synchronized）"><a href="#悲观锁（一人一单，synchronized）" class="headerlink" title="悲观锁（一人一单，synchronized）"></a>悲观锁（一人一单，<code>synchronized</code>）</h3><h4 id="public-String-intern"><a href="#public-String-intern" class="headerlink" title="public String intern()"></a>public String intern()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NotNull</span> </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">intern</span><span class="params">()</span></span><br><span class="line">返回字符串对象的规范表示形式。</span><br><span class="line">字符串池 (最初为空) 由类String私有维护。</span><br><span class="line">当intern方法被调用时，如果该池已经包含了一个与string对象相等的字符串 (由equals (object) 方法确定)，则返回该池中的字符串。否则，将该String对象添加到池中，并返回对该String对象的引用。</span><br><span class="line">因此，对于任意两个字符串s和t，s.<span class="type">int</span> <span class="title function_">ern</span><span class="params">()</span> = = t.<span class="type">int</span> <span class="title function_">ern</span><span class="params">()</span> 为<span class="literal">true</span>当且仅当s.equals(t) 为<span class="literal">true</span>。</span><br><span class="line">所有字面字符串和字符串值常量表达式都被插入。字符串文字在Java的第<span class="number">3.10</span><span class="number">.5</span>节中定义™语言规范。</span><br><span class="line">返回值:</span><br><span class="line">具有与此字符串相同内容的字符串，但保证来自唯一字符串池。</span><br><span class="line">外部 注解:</span><br><span class="line">@ org.jetbrains.annotations.NotNull</span><br><span class="line">  &lt; <span class="number">8</span> &gt; (rt.jar)</span><br></pre></td></tr></table></figure>

<h4 id="先提交事务再释放锁"><a href="#先提交事务再释放锁" class="headerlink" title="先提交事务再释放锁"></a>先提交事务再释放锁</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (userId.toString().intern()) &#123;</span><br><span class="line">    <span class="keyword">return</span> createVoucherOrder(voucherId, userId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId, Long userId)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="发现事务失效"><a href="#发现事务失效" class="headerlink" title="发现事务失效"></a>发现事务失效</h4><ol>
<li>未启用spring事务管理功能</li>
<li>方法不是public类型的</li>
<li>数据源未配置事务管理器</li>
<li>自身调用问题</li>
<li>异常类型错误</li>
<li>异常被吞了</li>
<li>业务和spring事务代码必须在一个线程中</li>
</ol>
<h5 id="未启用spring事务管理功能"><a href="#未启用spring事务管理功能" class="headerlink" title="未启用spring事务管理功能"></a><strong>未启用spring事务管理功能</strong></h5><p><code>@EnableTransactionManagement</code> 注解用来启用spring事务自动管理事务的功能，这个注解千万不要忘记写了。</p>
<h5 id="方法不是public类型的"><a href="#方法不是public类型的" class="headerlink" title="方法不是public类型的"></a><strong>方法不是public类型的</strong></h5><p>@Transaction 可以用在类上、接口上、public方法上，如果将<code>@Trasaction</code>用在了非public方法上，事务将无效。</p>
<h5 id="数据源未配置事务管理器"><a href="#数据源未配置事务管理器" class="headerlink" title="数据源未配置事务管理器"></a><strong>数据源未配置事务管理器</strong></h5><p>spring是通过事务管理器了来管理事务的，一定不要忘记配置事务管理器了，要注意为每个数据源配置一个事务管理器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> PlatformTransactionManager <span class="title function_">transactionManager</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>(dataSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="自身调用问题"><a href="#自身调用问题" class="headerlink" title="自身调用问题"></a><strong>自身调用问题</strong></h5><p>spring是通过AOP的方式，对需要spring管理事务的bean生成了代理对象，然后通过代理对象拦截了目标方法的执行，在方法前后添加了事务的功能，所以必须通过代理对象调用目标方法的时候，事务才会起效。</p>
<p>看下面代码，大家思考一个问题：当外部直接调用m1的时候，m2方法的事务会生效么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.m2();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//执行db操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然不会生效，因为m1中通过this的方式调用了m2方法，而this并不是代理对象，this.m2()不会被事务拦截器，所以事务是无效的，如果外部直接调用通过<code>UserService</code>这个bean来调用m2方法，事务是有效的，上面代码可以做一下调整，如下，@1在<code>UserService</code>中注入了自己，此时m1中的m2事务是生效的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">//@1</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userService.m2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//执行db操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>重点：必须通过代理对象访问方法，事务才会生效。</strong></p>
<h5 id="异常类型错误"><a href="#异常类型错误" class="headerlink" title="异常类型错误"></a><strong>异常类型错误</strong></h5><p>spring事务回滚的机制：对业务方法进行try catch，当捕获到有指定的异常时，spring自动对事务进行回滚，那么问题来了，哪些异常spring会回滚事务呢？</p>
<p>并不是任何异常情况下，spring都会回滚事务，默认情况下，<code>RuntimeException</code>和<code>Error</code>的情况下，spring事务才会回滚。</p>
<p>也可以自定义回滚的异常类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = &#123;异常类型列表&#125;)</span></span><br></pre></td></tr></table></figure>

<h5 id="异常被吞了"><a href="#异常被吞了" class="headerlink" title="异常被吞了"></a><strong>异常被吞了</strong></h5><p>当业务方法抛出异常，spring感知到异常的时候，才会做事务回滚的操作，若方法内部将异常给吞了，那么事务无法感知到异常了，事务就不会回滚了。</p>
<p>如下代码，事务操作2发生了异常，但是被捕获了，此时事务并不会被回滚</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">    事务操作<span class="number">1</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        事务操作<span class="number">2</span>，内部抛出了异常</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="业务和spring事务代码必须在一个线程中"><a href="#业务和spring事务代码必须在一个线程中" class="headerlink" title="业务和spring事务代码必须在一个线程中"></a><strong>业务和spring事务代码必须在一个线程中</strong></h5><p>spring事务实现中使用了<code>ThreadLocal</code>，<code>ThreadLocal</code>大家应该知道吧，可以实现同一个线程中数据共享，必须是同一个线程的时候，数据才可以共享，这就要求业务代码必须和spring事务的源码执行过程必须在一个线程中，才会受spring事务的控制，比如下面代码，方法内部的子线程内部执行的事务操作将不受m1方法上spring事务的控制，这个大家一定要注意</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">        一系列事务操作</span><br><span class="line">    &#125;.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解决事务失效"><a href="#解决事务失效" class="headerlink" title="解决事务失效"></a>解决事务失效</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//            获取代理对象</span></span><br><span class="line"><span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> ((IVoucherOrderService) AopContext.currentProxy());</span><br><span class="line"><span class="keyword">return</span> proxy.createVoucherOrder(voucherId, userId);</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--添加依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 启动类开启相关配置</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(exposeProxy = true)</span></span><br></pre></td></tr></table></figure>

<h2 id="Redis序列化问题"><a href="#Redis序列化问题" class="headerlink" title="Redis序列化问题"></a><code>Redis</code>序列化问题</h2><p><img src="/../Gallery/assets/20201229180349554.png" alt="在这里插入图片描述"></p>
<h2 id="使用Redis实现分布式锁"><a href="#使用Redis实现分布式锁" class="headerlink" title="使用Redis实现分布式锁"></a>使用<code>Redis</code>实现分布式锁</h2><p><img src="/../Gallery/assets/f1030e64d3524e408aace3195c529a5a.png" alt="在这里插入图片描述"></p>
<p><img src="/../Gallery/assets/1805b72252e74ab7af85655e88b0f7a0.png" alt="在这里插入图片描述"></p>
<h3 id="定义锁"><a href="#定义锁" class="headerlink" title="定义锁"></a>定义锁</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleRedisLock</span> <span class="keyword">implements</span> <span class="title class_">ILock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;lock:&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RedisTemplate&lt;String, String&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleRedisLock</span><span class="params">(String name, RedisTemplate&lt;String, String&gt; redisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> redisTemplate.opsForValue().setIfAbsent(KEY_PREFIX + name, Long.toString(threadId), timeoutSec, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE.equals(success);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        redisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取锁对象并使用"><a href="#获取锁对象并使用" class="headerlink" title="获取锁对象并使用"></a>获取锁对象并使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line"><span class="comment">//            创建锁的对象</span></span><br><span class="line"><span class="type">SimpleRedisLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleRedisLock</span>(<span class="string">&quot;order:&quot;</span> + userId, redisTemplate);</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">    <span class="comment">//            获取锁失败,返回错误或重试</span></span><br><span class="line">    <span class="keyword">return</span> Result.fail(<span class="string">&quot;不允许重复下单&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//            获取代理对象</span></span><br><span class="line">    <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> ((IVoucherOrderService) AopContext.currentProxy());</span><br><span class="line">    <span class="keyword">return</span> proxy.createVoucherOrder(voucherId, userId);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p><img src="/../Gallery/assets/3cdf34b691ba4ccba8678e4fe153a724.png" alt="在这里插入图片描述"></p>
<h3 id="改进Redis分布式锁-解决锁的误删"><a href="#改进Redis分布式锁-解决锁的误删" class="headerlink" title="改进Redis分布式锁(解决锁的误删)"></a>改进<code>Redis</code>分布式锁(解决锁的误删)</h3><h4 id="添加锁的线程表示（UUID）"><a href="#添加锁的线程表示（UUID）" class="headerlink" title="添加锁的线程表示（UUID）"></a>添加锁的线程表示（<code>UUID</code>）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> redisTemplate.opsForValue().setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Boolean.TRUE.equals(success);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">    <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> redisTemplate.opsForValue().get(KEY_PREFIX + name);</span><br><span class="line">    <span class="keyword">if</span> (threadId.equals(id)) &#123;</span><br><span class="line">        redisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解决多条命令的原子性问题"><a href="#解决多条命令的原子性问题" class="headerlink" title="解决多条命令的原子性问题"></a>解决多条命令的原子性问题</h3><h4 id="Lua脚本编写"><a href="#Lua脚本编写" class="headerlink" title="Lua脚本编写"></a><code>Lua</code>脚本编写</h4><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;get&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h4 id="Lua脚本获取"><a href="#Lua脚本获取" class="headerlink" title="Lua脚本获取"></a><code>Lua</code>脚本获取</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    UNLOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">    UNLOCK_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;unlock.lua&quot;</span>));</span><br><span class="line">    UNLOCK_SCRIPT.setResultType(Long.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Lua脚本调用"><a href="#Lua脚本调用" class="headerlink" title="Lua脚本调用"></a><code>Lua</code>脚本调用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//        调用lua脚本</span></span><br><span class="line">    redisTemplate.execute(UNLOCK_SCRIPT, Collections.singletonList(KEY_PREFIX + name), ID_PREFIX + Thread.currentThread().getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基于-setnx-实现的分布式锁存在下面的问题"><a href="#基于-setnx-实现的分布式锁存在下面的问题" class="headerlink" title="基于 setnx 实现的分布式锁存在下面的问题"></a>基于 <code>setnx </code>实现的分布式锁存在下面的问题</h3><h4 id=""><a href="#" class="headerlink" title=""></a><img src="/../Gallery/assets/image-20230920092748413.png" alt="image-20230920092748413"></h4><h3 id="Redisson-是一个在-Redis-的基础上实现的-Java-驻内存数据网格"><a href="#Redisson-是一个在-Redis-的基础上实现的-Java-驻内存数据网格" class="headerlink" title="Redisson 是一个在 Redis 的基础上实现的 Java 驻内存数据网格"></a><code>Redisson </code>是一个在 <code>Redis</code> 的基础上实现的 Java 驻内存数据网格</h3><p>它不仅提供了一系列的分布式的 Java 常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。</p>
<p><strong>说白了就是一个封装各种锁且十分完善的工具，前面又白雪了，分布式锁轮子人家已经做的很完善了，咱学的就是个思想</strong></p>
<h4 id="要使用Redisson，先导入它的坐标"><a href="#要使用Redisson，先导入它的坐标" class="headerlink" title="要使用Redisson，先导入它的坐标"></a>要使用Redisson，先导入它的坐标</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.13.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Redisson类"><a href="#Redisson类" class="headerlink" title="Redisson类"></a><code>Redisson</code>类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissionClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 配置类</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        <span class="comment">// 添加 Redis 地址，此处添加了单点的地址，也可以使用 config.useClusterServers() 添加集群地址</span></span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://192.168.2.12:6379&quot;</span>).setPassword(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建客户端</span></span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="使用Redisson的分布式锁"><a href="#使用Redisson的分布式锁" class="headerlink" title="使用Redisson的分布式锁"></a>使用<code>Redisson</code>的分布式锁</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testRedisson</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 获取锁（可重入），指定锁的名称</span></span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;anyLock&quot;</span>);</span><br><span class="line">    <span class="comment">// 尝试获取锁，参数分别是：获取锁的最大等待时间（期间会重试过），锁自动释放时间，时间单位</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">1</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="comment">// 判断锁是否获取成功</span></span><br><span class="line">    <span class="keyword">if</span> (isLock) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行业务&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分布式锁总结："><a href="#分布式锁总结：" class="headerlink" title="分布式锁总结："></a>分布式锁总结：</h2><p><img src="/../Gallery/assets/image-20230920143534250.png" alt="image-20230920143534250"></p>
<h2 id="Redis优化异步秒杀"><a href="#Redis优化异步秒杀" class="headerlink" title="Redis优化异步秒杀"></a><code>Redis</code>优化异步秒杀</h2><p><img src="/../Gallery/assets/b9c54dc26288497ab23ff3832435c029.png" alt="在这里插入图片描述"></p>
<h3 id="为避免所有操作都在数据库上执行，分离成两个线程，一个线程判断用户的购买资格，发现用户有购买资格后再开启一个独立的线程来处理耗时较久的减库存、写订单的操作。"><a href="#为避免所有操作都在数据库上执行，分离成两个线程，一个线程判断用户的购买资格，发现用户有购买资格后再开启一个独立的线程来处理耗时较久的减库存、写订单的操作。" class="headerlink" title="为避免所有操作都在数据库上执行，分离成两个线程，一个线程判断用户的购买资格，发现用户有购买资格后再开启一个独立的线程来处理耗时较久的减库存、写订单的操作。"></a>为避免所有操作都在数据库上执行，分离成两个线程，一个线程判断用户的购买资格，发现用户有购买资格后再开启一个独立的线程来处理耗时较久的减库存、写订单的操作。</h3><p>可以将耗时较短的两步操作放到 Redis 中，在 Redis 中处理对应的秒杀资格的判断。Redis 的性能是比 MySQL 要好的。此外，还需要引入异步队列记录相关的信息。</p>
<p><img src="/../Gallery/assets/7c28b3c9c2cb47848da9ecdf630d41cd.png" alt="![在这里插入图片描述](https://img-blog.csdnimg.cn/4de5f8ca98914b588910a89ccf165f11.png"></p>
<h3 id="生产用户Token"><a href="#生产用户Token" class="headerlink" title="生产用户Token"></a>生产用户Token</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;User&gt; Users = userService.list();</span><br><span class="line"></span><br><span class="line">Users.forEach(userDTO -&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Object&gt; beanToMap = BeanUtil.beanToMap(userDTO, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(),</span><br><span class="line">                                                       CopyOptions.create()</span><br><span class="line">                                                       .setIgnoreNullValue(<span class="literal">true</span>)</span><br><span class="line">                                                       .setFieldValueEditor((fieldName, fieldValue) -&gt; fieldValue.toString()));</span><br><span class="line"></span><br><span class="line">    redisTemplate.opsForHash().putAll(RedisConstants.LOGIN_USER_KEY + token, beanToMap);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="导出用户Token"><a href="#导出用户Token" class="headerlink" title="导出用户Token"></a>导出用户Token</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli KEYS &quot;login:token:*&quot; | ForEach-Object &#123;</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">key = <span class="variable">$_</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">value = redis-cli GET <span class="variable">$key</span></span></span><br><span class="line">&quot;$key,$value&quot;</span><br><span class="line">&#125; | Out-File -FilePath &quot;redis_data.csv&quot; -Encoding utf8</span><br></pre></td></tr></table></figure>

<h3 id="BlockingQueue这个阻塞队列特点：当一个线程尝试从队列获取元素的时候，如果没有元素该线程阻塞，直到队列中有元素才会被唤醒并获取元素"><a href="#BlockingQueue这个阻塞队列特点：当一个线程尝试从队列获取元素的时候，如果没有元素该线程阻塞，直到队列中有元素才会被唤醒并获取元素" class="headerlink" title="BlockingQueue这个阻塞队列特点：当一个线程尝试从队列获取元素的时候，如果没有元素该线程阻塞，直到队列中有元素才会被唤醒并获取元素"></a>BlockingQueue这个阻塞队列特点：当一个线程尝试从队列获取元素的时候，如果没有元素该线程阻塞，直到队列中有元素才会被唤醒并获取元素</h3><p>①编写lua脚本，对于超卖问题和一人一单进行解决处理，超卖用CAS方法判断库存是否大于0，一人一单用redis的set集合的sismenber判读该优惠券（key）下的用户id（value）是否唯一</p>
<p>②Java代码中注入脚本，并执行脚本判断脚本返回结果，若不为脚本结果0，直接返回错误提示</p>
<p>③若脚本结果为0，代表有购买优惠券资格，将new VoucherOrder创建订单对象，并set orderId，userId，voucherId。再把订单对象放入阻塞队列中，返回订单id给用户</p>
<p>④创建线程池，并定义线程任务，但注意，线程任务必须在方法执行前执行，使用到spring提供的注解在类初始化完成后执行线程任务</p>
<p>⑤线程任务中获取阻塞队列的订单对象，然后调用handleVoucherOrder方法传入voucherOrder</p>
<p>⑥handleVoucherOrder方法其实是再次获取锁，这个就是个纯兜底，作用不大。并在获取锁成功后调用createVoucherOrder方法扣减库存创建订单，由于都是对数据库的操作，因此要提交事务</p>
<h3 id="基于阻塞队列的异步秒杀存在哪些问题？"><a href="#基于阻塞队列的异步秒杀存在哪些问题？" class="headerlink" title="基于阻塞队列的异步秒杀存在哪些问题？"></a>基于阻塞队列的异步秒杀存在哪些问题？</h3><h4 id="内存限制问题-—-我们使用的是JDK里的阻塞队列，是基于JVM的内存，高并发海量请求下造成内存溢出还有服务宕机情况下内存数据丢失"><a href="#内存限制问题-—-我们使用的是JDK里的阻塞队列，是基于JVM的内存，高并发海量请求下造成内存溢出还有服务宕机情况下内存数据丢失" class="headerlink" title="内存限制问题 —&gt; 我们使用的是JDK里的阻塞队列，是基于JVM的内存，高并发海量请求下造成内存溢出还有服务宕机情况下内存数据丢失"></a>内存限制问题 —&gt; 我们使用的是JDK里的阻塞队列，是基于JVM的内存，高并发海量请求下造成内存溢出还有服务宕机情况下内存数据丢失</h4><h4 id="数据安全问题"><a href="#数据安全问题" class="headerlink" title="数据安全问题"></a>数据安全问题</h4><ul>
<li>队列满了怎么办 ？</li>
<li>子线程下单失败怎么办？</li>
<li>订单太多了超过阻塞队列大小了怎么办？</li>
<li>拒绝策略怎么设计？</li>
<li>待消费的消息是否应该持久化，不然宕机了消息不就丢失了？</li>
<li>还有如何确保消息确实被消费成功了，不然消费失败了无法重试</li>
</ul>
<h2 id="Redis消息队列"><a href="#Redis消息队列" class="headerlink" title="Redis消息队列"></a><code>Redis</code>消息队列</h2><p><img src="/../Gallery/assets/image-20230921084712487.png" alt="image-20230921084712487"></p>
<h2 id="Redisstream消息队列"><a href="#Redisstream消息队列" class="headerlink" title="Redisstream消息队列"></a><code>Redisstream</code>消息队列</h2><p><img src="/../Gallery/assets/image-20230921084545997.png" alt="image-20230921084545997"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = redisTemplate.opsForStream().read(</span><br><span class="line">    Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">    StreamReadOptions.empty().count(<span class="number">1</span>),</span><br><span class="line">    StreamOffset.create(queueName, ReadOffset.from(<span class="string">&quot;0&quot;</span>))</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>ID也可以指定0、其他ID或者不完整的ID（时间戳部分），但这样的话，Stream只会返回已传递给当前消费者并且没有被XACK确定的历史消息，即该消费者内部的pending_ids集合，在这种情况下，BLOCK 和 NOACK 都被忽略。</strong></p>
<h2 id="用户未登录查询是否点赞报空指针异常"><a href="#用户未登录查询是否点赞报空指针异常" class="headerlink" title="用户未登录查询是否点赞报空指针异常"></a>用户未登录查询是否点赞报空指针异常</h2><h3 id="对未登录用户跳过查询，直接返回"><a href="#对未登录用户跳过查询，直接返回" class="headerlink" title="对未登录用户跳过查询，直接返回"></a>对未登录用户跳过查询，直接返回</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">isBlogLiked</span><span class="params">(Blog blog)</span> &#123;</span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">    <span class="keyword">if</span> (ObjectUtil.isNotNull(user)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> user.getId();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.BLOG_LIKED_KEY + blog.getId();</span><br><span class="line"></span><br><span class="line">        <span class="type">Double</span> <span class="variable">score</span> <span class="operator">=</span> redisTemplate.opsForZSet().score(key, userId.toString());</span><br><span class="line"></span><br><span class="line">        blog.setIsLike(ObjectUtil.isNotNull(score));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="用zset对点赞列表进行存储"><a href="#用zset对点赞列表进行存储" class="headerlink" title="用zset对点赞列表进行存储"></a>用zset对点赞列表进行存储</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line"><span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.BLOG_LIKED_KEY + id;</span><br><span class="line"></span><br><span class="line"><span class="type">Double</span> <span class="variable">score</span> <span class="operator">=</span> redisTemplate.opsForZSet().score(key, userId.toString());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ObjectUtil.isNull(score)) &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> lambdaUpdate().setSql(<span class="string">&quot;liked = liked + 1&quot;</span>).eq(Blog::getId, id).update();</span><br><span class="line">    <span class="keyword">if</span> (isSuccess) &#123;</span><br><span class="line">        redisTemplate.opsForZSet().add(key, userId.toString(), System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> lambdaUpdate().setSql(<span class="string">&quot;liked = liked - 1&quot;</span>).eq(Blog::getId, id).update();</span><br><span class="line">    <span class="keyword">if</span> (isSuccess) &#123;</span><br><span class="line">        redisTemplate.opsForZSet().remove(key, userId.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注意：sql语句的-list-in（…-…）查询出来的是后点赞的在前，先点赞的在后，需要我们自定义sql查询-用last最后一条sql语句，手写order-by的sql，具体代码如下"><a href="#注意：sql语句的-list-in（…-…）查询出来的是后点赞的在前，先点赞的在后，需要我们自定义sql查询-用last最后一条sql语句，手写order-by的sql，具体代码如下" class="headerlink" title="注意：sql语句的 list.in（…, …）查询出来的是后点赞的在前，先点赞的在后，需要我们自定义sql查询,用last最后一条sql语句，手写order by的sql，具体代码如下"></a><strong>注意：sql语句的 list.in（…, …）查询出来的是后点赞的在前，先点赞的在后，需要我们自定义sql查询,用last最后一条sql语句，手写order by的sql，具体代码如下</strong></h2> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;ORDER BY FIELD(id,&quot;</span> + StrUtil.join(<span class="string">&quot;,&quot;</span>, ids) + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">List&lt;UserDTO&gt; userDTOS = userService.lambdaQuery()</span><br><span class="line">    .in(User::getId, ids).last(sql)</span><br><span class="line">    .list()</span><br><span class="line">    .stream().map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class)).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
</search>
